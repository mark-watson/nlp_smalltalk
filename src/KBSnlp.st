PackageManifest subclass: #ManifestKBSnlp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KBSnlp'!!ManifestKBSnlp commentStamp: 'MarkWatson 5/19/2017 06:24' prior: 0!Copyright 2005-2017 Mark Watson. All rights reserved. Licensed for use under the MIT license with attribution required.See:  https://github.com/mark-watson/nlp_smalltalk!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestKBSnlp class	instanceVariableNames: ''!!ManifestKBSnlp class methodsFor: 'code-critics' stamp: 'MarkWatson 5/14/2017 21:23'!ruleRBOnlyReadOrWrittenTemporaryRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'NLPsummarizer class' #summarize: #true)) #'2017-05-14T21:23:23.063039-07:00') )! !!ManifestKBSnlp class methodsFor: 'code-critics' stamp: 'MarkWatson 5/14/2017 21:25'!ruleRBToDoCollectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'NLPsummarizer class' #summarize: #true)) #'2017-05-14T21:25:54.536453-07:00') )! !Object subclass: #NLPcategories	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KBSnlp'!!NLPcategories commentStamp: 'MarkWatson 5/19/2017 06:25' prior: 0!A NLPcategories is class to categorize text.Copyright 2005-2017 Mark Watson. All rights reserved. Licensed for use under the MIT license with attribution required.See:  https://github.com/mark-watson/nlp_smalltalk!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPcategories class	instanceVariableNames: ''!!NLPcategories class methodsFor: 'classify' stamp: 'MarkWatson 1/13/2015 14:09'!classify: text	"classify text in a string"	| tokens categories scores num hash numTokens results cutoff |	tokens :=  NLPtagger tokenize: (text , 'XXXXXX').	categories := (Smalltalk at: #NlpCategoryHash) keys.	num := categories size.	numTokens := tokens size - 1.	scores := Array new: num.	1 to: num do: [ :i |		scores at: i put: 0.		hash := (Smalltalk at: #NlpCategoryHash) at: (categories at: i).		1 to: numTokens do: [ :j |			(hash includesKey: (tokens at: j))			  ifTrue: [scores at: i put: ((scores at: i) + (hash at: (tokens at: j)))] ].		hash := (Smalltalk at: #NlpCategory2gramHash) at: (categories at: i).		1 to: numTokens do: [ :j |			(hash includesKey: ((tokens at: j) , ' ' , (tokens at: j + 1)))			  ifTrue: [scores at: i put: ((scores at: i)+ ((hash at: (tokens at: j) , ' ' , (tokens at: j + 1)) * 8))]]].	results := SortedCollection sortBlock: [:c1 :c2 | (c1 at:1) > (c2 at:1)]. 	1 to: num do: [ :i | |a| a := (Array new: 2). a at: 1 put: (scores at:i); at: 2 put: (categories at: i). results add: a ].	cutoff := ((results at: 1) at: 1) / 2.	results := results select: [ :x | (x at: 1) > cutoff ].	^results.	! !!NLPcategories class methodsFor: 'classify' stamp: 'MarkWatson 1/13/2015 13:59'!initializeCategoryHash	"requires NeoJSON"     Smalltalk at: #NlpCategoryHash                    put: (NeoJSONReader fromString: (FileStream fileNamed: './nlp_smalltalk/tags.json') contentsOfEntireFile).     Smalltalk at: #NlpCategory2gramHash                    put: (NeoJSONReader fromString: (FileStream fileNamed: './nlp_smalltalk/tags_2gram.json') contentsOfEntireFile)! !Object subclass: #NLPentities	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KBSnlp'!!NLPentities commentStamp: 'MarkWatson 5/19/2017 06:25' prior: 0!A NLPentities is a class to find people's names, company names, place names, etc. in text.Copyright 2005-2017 Mark Watson. All rights reserved. Licensed for use under the MIT license with attribution required.See:  https://github.com/mark-watson/nlp_smalltalk!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPentities class	instanceVariableNames: ''!!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 1/13/2015 10:32'!entities: aString	"return a Dictionary of entities (keys type, values Sets"	| temp result |	result := Dictionary new.	temp := NLPentities entityHelper: (Smalltalk at: #NLPcompanyNames) text: aString.	temp size > 0		ifTrue: [ result at: 'companies' put: temp ].	temp := NLPentities entityHelper: (Smalltalk at: #NLPproductNames) text: aString.	temp size > 0		ifTrue: [ result at: 'products' put: temp ].	temp := NLPentities entityHelper: (Smalltalk at: #NLPplaceNames) text: aString.	temp size > 0		ifTrue: [ result at: 'places' put: temp ].	temp := NLPentities humanNameHelper: aString.	temp size > 0		ifTrue: [ result at: 'places' put: temp ].	^ result! !!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 1/13/2015 10:32'!humanNameHelper: aString	"this is a helper method for everything **but** person names"	| tokens num results |	results := Set new.	tokens := NLPtagger tokenize: aString , ' xxxxx yyyyy zzzzz'.	num := tokens size - 3.	" account for the 3 fake tokens at the end "	1 to: num do: [ :i | 		((Smalltalk at: #NLPfirstNames) includes: (tokens at: i))			ifTrue: [ 				(((Smalltalk at: #NLPfirstNames) includes: (tokens at: i + 1))					and: ((Smalltalk at: #NLPlastNames) includes: (tokens at: i + 2)))					ifTrue: [ 						results add: (tokens at: i) , ' ' , (tokens at: i + 1) , ' ' , (tokens at: i + 2).						i := i + 2 ]					ifFalse: [ 						((Smalltalk at: #NLPlastNames) includes: (tokens at: i + 1))							ifTrue: [ 								results add: (tokens at: i) , ' ' , (tokens at: i + 1).								i := i + 1 ] ] ] ].	^ results! !!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 1/13/2015 10:33'!entityHelper: entitySet text: aString	"this is a helper method for everything **but** person names"	| tokens num ngram2 ngram3 results |	results := Set new.	tokens := NLPtagger tokenize: aString , ' xxxxx yyyyy zzzzz'.	num := tokens size - 3.	" account for the 3 fake tokens at the end "	1 to: num do: [ :i | 		ngram2 := (tokens at: i) , ' ' , (tokens at: i + 1).		ngram3 := ngram2 , ' ' , (tokens at: i + 2).	"Transcript show: ngram2; cr."		(entitySet includes: ngram3)			ifTrue: [ results add: ngram3 ]			ifFalse: [ 				(entitySet includes: ngram2)					ifTrue: [ results add: ngram2 ]					ifFalse: [ 						(entitySet includes: (tokens at: i))							ifTrue: [ results add: (tokens at: i) ] ] ] ].	^ results! !!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 1/12/2015 15:43'!fileToDictionary: filePath	"Read data/lexicon.txt and build in memory lexicon"      | read count  aLine  strm  set |      Transcript show: 'Processing file ' , filePath; cr.	set := Set new.	read := (MultiByteFileStream fileNamed: filePath) readOnly.	count := 0.	[read atEnd]		whileFalse: [count := count + 1.			aLine := read upTo: Character lf.	"Mac: use lf, Windows: use cr ???"			"look for a space character: "			((aLine indexOf: $:) > 0)			  ifTrue: [ 				 strm := ReadStream on: aLine.			       aLine := strm upTo: $:].			set add: aLine].	read close.	^set! !!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 5/16/2017 20:36'!initializeEntities	"load entity name data"	" Note: place name lines of the form: Cairo:country_capital   Fixed in fileToDictionary "	Smalltalk		at: #NLPcompanyNames		put: (NLPentities fileToDictionary: './nlp_smalltalk/company_names.txt').	Smalltalk		at: #NLPfirstNames		put: (NLPentities fileToDictionary: './nlp_smalltalk/firstnames.txt').	Smalltalk		at: #NLPlastNames		put: (NLPentities fileToDictionary: './nlp_smalltalk/lastnames.txt').	Smalltalk		at: #NLPhonorifics		put: (NLPentities fileToDictionary: './nlp_smalltalk/honorifics.txt').	Smalltalk		at: #NLPprefixNames		put: (NLPentities fileToDictionary: './nlp_smalltalk/prefixnames.txt').	Smalltalk		at: #NLPplaceNames		put: (NLPentities fileToDictionary: './nlp_smalltalk/placenames.txt').	Smalltalk		at: #NLPproductNames		put: (NLPentities fileToDictionary: './nlp_smalltalk/product_names.txt').			" also read in data we will need for sentence segmentation: "	Smalltalk		at: #NLPtokensWithPeriods		put: (NLPentities fileToDictionary: './nlp_smalltalk/tokens_with_periods.txt').! !Object subclass: #NLPsentences	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KBSnlp'!!NLPsentences commentStamp: 'MarkWatson 5/19/2017 06:26' prior: 0!A class to segment text into sentences.Copyright 2005-2017 Mark Watson. All rights reserved. Licensed for use under the MIT license with attribution required.See:  https://github.com/mark-watson/nlp_smalltalk!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPsentences class	instanceVariableNames: ''!!NLPsentences class methodsFor: 'initialize' stamp: 'MarkWatson 5/18/2017 16:42'!loadData	"Load tokens that normally contain periods"	| aSet count reverseDictionary forwardDictionary |	count := 0.	reverseDictionary := Dictionary new.	forwardDictionary := Dictionary new.	aSet := NLPsentences fileToSet: './nlp_smalltalk/tokensWithPeriods.txt'.	Smalltalk at: #NLPtokensWithPeriods put: aSet.	^ 'tokens with periods data loaded'! !!NLPsentences class methodsFor: 'segment' stamp: 'MarkWatson 5/18/2017 16:33'!sentences: someText	"tokenize a string into individual sentences"	| tokens aSet lastToken currentSentence allSentences |	aSet := Smalltalk at: #NLPtokensWithPeriods.	tokens := OrderedCollection new.	(NLPsentences tokenizeLeavePeriods: someText)		do: [ :token | 			(token includesSubstring: '.') not				ifTrue: [ tokens add: token ]				ifFalse: [ (aSet includes: token)						ifFalse: [ tokens add: (token copyWithRegex: '\.' matchesReplacedWith: '').							tokens add: '.' ]						ifTrue: [ tokens add: token ] ] ].	currentSentence := OrderedCollection new.	allSentences := OrderedCollection new.	lastToken := ''.	Transcript		show: tokens;		cr.	tokens		do: [ :token | 			Transcript				show: token;				cr.			currentSentence add: token.			((token = '.' and: lastToken isAllDigits not) or: token = '?')				ifTrue: [ allSentences addLast: currentSentence.					currentSentence := OrderedCollection new ].			lastToken := token ].	currentSentence isNotEmpty		ifTrue: [ allSentences addLast: currentSentence ].	^ allSentences! !!NLPsentences class methodsFor: 'utiities' stamp: 'MarkWatson 5/18/2017 13:42'!fileToSet: filePath	"Read file, create Set with elements being each line in file"	| read aLine set |	Transcript		show: 'Processing file ' , filePath;		cr.	set := Set new.	read := (MultiByteFileStream fileNamed: filePath) readOnly.	[ read atEnd ]		whileFalse: [ aLine := read upTo: Character lf.	"Mac: use lf, Windows: use cr ???"			set add: aLine ].	read close.	^ set! !!NLPsentences class methodsFor: 'utiities' stamp: 'MarkWatson 5/18/2017 15:31'!tokenizeLeavePeriods: wordsInAString	"tokenizes a string"	^ wordsInAString		findTokens:			' ;:,<>[]{}!!@#$%^&*()?'		keep: ';:.,<>[]{}!!$?'	" keep CR in this string!!!! "! !Object subclass: #NLPsummarizer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KBSnlp'!!NLPsummarizer commentStamp: 'MarkWatson 5/19/2017 06:26' prior: 0!A class to classify English text into categories.Copyright 2005-2017 Mark Watson. All rights reserved. Licensed for use under the MIT license with attribution required.See:  https://github.com/mark-watson/nlp_smalltalk!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPsummarizer class	instanceVariableNames: ''!!NLPsummarizer class methodsFor: 'summary' stamp: 'MarkWatson 5/15/2017 09:34'!summarize: text	"extractive summarizer"	| sentences sentenceScores tokens scoredCategories hash x bestIndices |	scoredCategories := NLPcategories classify: text.	sentences := NLPtagger sentences: text.	sentenceScores := Array new: sentences size.	1 to: sentences size do: [ :i | 		sentenceScores at: i put: 0.		tokens := sentences at: i.		Transcript			show: (sentences at: i);			cr.		scoredCategories			do: [ :sc | 				hash := (Smalltalk at: #NlpCategoryHash) at: (sc at: 2).				tokens					do: [ :token | 						(hash includesKey: token)							ifTrue: [ x := hash at: token.								sentenceScores at: i put: (sentenceScores at: i) + (sc at: 1) ] ] ] ].	bestIndices := sentenceScores		collectWithIndex: [ :score :i | 			{score.			i} ].	Transcript		show: 'sentence scoring: ';		show: bestIndices;		cr.	bestIndices := bestIndices select: [ :p | (p at: 1) > 2 ].	^ bestIndices collect: [ :p | Character space join: (sentences at: (p at: 2)) ]! !Object subclass: #NLPtagger	instanceVariableNames: ''	classVariableNames: 'NLPlexicon'	poolDictionaries: ''	category: 'KBSnlp'!!NLPtagger commentStamp: 'MarkWatson 5/19/2017 06:27' prior: 0!NLP tagger converted to Squeak.A class that implements an NLP tagger.Copyright 2005-2017 Mark Watson. All rights reserved. Licensed for use under the MIT license with attribution required.See:  https://github.com/mark-watson/nlp_smalltalk!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPtagger class	instanceVariableNames: ''!!NLPtagger class methodsFor: 'segmentation' stamp: 'MarkWatson 5/16/2017 20:43'!sentences: data	"Handle either a string or array of tokens.	 Limitations:	  1. This code does not currently handle special characters like —	  2. Periods in numbers: only check previous character, not the	     next so a sentence ending with e.g., 2. will not be handled correctly.      	"	| tokens lastToken currentSentence allSentences token |	tokens := (data isMemberOf: ByteString)		ifTrue: (NLPtagger tokenize: data)		ifFalse: data.	currentSentence := OrderedCollection new.	allSentences := OrderedCollection new.	lastToken := ''.	Transcript		show: tokens;		cr.	tokens		do: [ :token1 | 			((Smalltalk at: #NLPtokensWithPeriods) includes: token1)			  ifTrue: [ token := (Smalltalk at: #NLPtokensWithPeriods) get: token1 ]			  ifFalse: [ token := token1 ].			Transcript				show: token;				cr.			currentSentence add: token.			((token = '.' and: lastToken isAllDigits not) or: token = '?')				ifTrue: [ allSentences addLast: currentSentence.					currentSentence := OrderedCollection new ].			lastToken := token ].	currentSentence isNotEmpty		ifTrue: [ allSentences addLast: currentSentence ].	^ allSentences! !!NLPtagger class methodsFor: 'tagging' stamp: 'MW 1/27/2008 12:53'!tag: words	"tag an ordered collection of words, returning an ordered collection of corresponding tags"	| lex tags tag count i word lastWord lastTag |	tags := OrderedCollection new.	lex := Smalltalk at: #NLPlexicon.	words do: 			[:aWord | 			tag := lex at: aWord ifAbsent: [nil].			tag isNil ifFalse: [tag := tag at: 1] ifTrue: [tag := 'NN'].	" the default tag "			tags add: tag].	" Apply transformation rules: "	lastWord := ''.	lastTag := ''.	i := 0.	count := words size.	[i < count] whileTrue: 			[i := i + 1.			word := words at: i.			tag := tags at: i.	" reuse tag variable "			" First, handle all rules for i &gt; 1 "			i > 1 				ifTrue: 					[" rule 1: DT, {VBD | VBP} --> DT, NN "					lastTag = 'DT' & (tag = 'VBD' | (tag = 'VBP') | (tag = 'VB')) 						ifTrue: [tags at: i put: 'NN'].					tag size > 1 						ifTrue: 							[" rule 6: convert a noun to a verb if the preceeding work is 'would' "							(tag at: 1) = $N & ((tag at: 2) = $N) & (lastWord asLowercase = 'would') 								ifTrue: [tags at: i put: 'VB']]].			" Now, handle the remaining rules that are valid for i = 1: "			" rule 2: convert a noun to a number (CD) if '.' appears in the word"			(word findString: '.') > 0 				ifTrue: [(tag at: 1) = $N ifTrue: [tags at: i put: 'CD']].	" not working - tokenizer tosses '.' characters "			" rule 3: convert a noun to a past participle if words[i] ends with 'ed' "			(tag at: 1) = $N & (word endsWith: 'ed') ifTrue: [tags at: i put: 'VBN'].			" rule 4: convert any type to adverb if it ends in 'ly' "			(word endsWith: 'ly') ifTrue: [tags at: i put: 'RB'].			" rule 5: convert a common noun (NN or NNS) to a adjective if it ends with 'al' "			(tag at: 1) = $N & (word endsWith: 'al') ifTrue: [tags at: i put: 'JJ'].			" rule 7: if a word has been categorized as a common noun and it ends with 's;, "			"          then set its type to plural common noun (NNS) "			tag = 'NN' & (word endsWith: 's') ifTrue: [tags at: i put: 'NNS'].			" rule 8: convert a common noun to a present prticiple verb (i.e., a gerand) "			(tag at: 1) = $N & (word endsWith: 'ing') ifTrue: [tags at: i put: 'VBG'].			lastWord := word.			lastTag := tag].	^tags! !!NLPtagger class methodsFor: 'tagging' stamp: 'MW 1/27/2008 13:21'!pptag: wordString 	"returns a string of word/tag ..."	| words tags write size count |	words := NLPtagger tokenize: wordString.	tags := NLPtagger tag: words.	write := TextStream on: String new.	size := words size.	count := 1.	[count <= size]		whileTrue: [			write nextPutAll: (words at: count).			write nextPutAll: '/'.			write nextPutAll: (tags at: count).			write nextPutAll: ' '.			count := count + 1].	^write contents string! !!NLPtagger class methodsFor: 'tagging' stamp: 'MarkWatson 5/18/2017 16:37'!initializeLexicon	"Read data/lexicon.txt and build in memory lexicon"	| read count strm aLine word taglist token lex |	lex := Dictionary new.	read := (FileStream fileNamed: './nlp_smalltalk/lexicon.txt') readOnly.	count := 0.	[ read atEnd ]		whileFalse: [ count := count + 1.			aLine := read upTo: Character lf.	"Mac: use lf, Windows: use cr ???"			strm := ReadStream on: aLine.			word := strm upTo: Character space.			taglist := OrderedCollection new.			[ strm atEnd ]				whileFalse: [ token := strm upTo: Character space.					taglist add: token ].			"Transcript show: word; cr."			"Transcript show: taglist printString; cr."			lex at: word put: taglist ].	read close.	Smalltalk at: #NLPlexicon put: lex! !!NLPtagger class methodsFor: 'tokenization' stamp: 'MarkWatson 5/15/2017 10:11'!tokenize: wordsInAString	"tokenizes a string"	^ wordsInAString		findTokens:			' ;:.,<>[]{}!!@#$%^&*()?'		keep: ';:.,<>[]{}!!$?'	" keep CR in this string!!!! "! !