Object subclass: #NLPtagger	instanceVariableNames: ''	classVariableNames: 'NLPlexicon'	poolDictionaries: ''	category: 'KBSnlp'!!NLPtagger commentStamp: 'MW 1/27/2008 12:20' prior: 0!NLP tagger converted to Squeak.Copyring 2000-2008 Mark Watson. All rights reserved.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPtagger class	instanceVariableNames: ''!!NLPtagger class methodsFor: 'tagging' stamp: 'MW 1/27/2008 12:29'!tokenize: wordsInAString 	"This method is modified by ADvance."	"tokenizes a string"	^wordsInAString findTokens: ' ;:.,<>[]{}!!@#$%^&*()?' keep: ';:.,<>[]{}!!$'   " keep CR in this string!!!! "! !!NLPtagger class methodsFor: 'tagging' stamp: 'MW 1/27/2008 12:50'!initializeLexicon	"Read data/lexicon.txt and build in memory lexicon"	| read count strm aLine word taglist token lex |	lex := Dictionary new.	read := (FileStream fileNamed: './nlp_smalltalk/lexicon.txt') readOnly.	count := 0.	[read atEnd]		whileFalse: [count := count + 1.			aLine := read upTo: Character lf.	"Mac: use lf, Windows: use cr ???"			strm := ReadStream on: aLine.			word := strm upTo: Character space.			taglist := OrderedCollection new.			[strm atEnd]				whileFalse: [token := strm upTo: Character space.					taglist add: token].			"Transcript show: word; cr."			"Transcript show: taglist printString; cr."			lex at: word put: taglist].	read close.	lex inspect.	Smalltalk at: #NLPlexicon put: lex! !!NLPtagger class methodsFor: 'tagging' stamp: 'MW 1/27/2008 13:21'!pptag: wordString 	"returns a string of word/tag ..."	| words tags write size count |	words := NLPtagger tokenize: wordString.	tags := NLPtagger tag: words.	write := TextStream on: String new.	size := words size.	count := 1.	[count <= size]		whileTrue: [			write nextPutAll: (words at: count).			write nextPutAll: '/'.			write nextPutAll: (tags at: count).			write nextPutAll: ' '.			count := count + 1].	^write contents string! !!NLPtagger class methodsFor: 'tagging' stamp: 'MW 1/27/2008 12:53'!tag: words	"tag an ordered collection of words, returning an ordered collection of corresponding tags"	| lex tags tag count i word lastWord lastTag |	tags := OrderedCollection new.	lex := Smalltalk at: #NLPlexicon.	words do: 			[:aWord | 			tag := lex at: aWord ifAbsent: [nil].			tag isNil ifFalse: [tag := tag at: 1] ifTrue: [tag := 'NN'].	" the default tag "			tags add: tag].	" Apply transformation rules: "	lastWord := ''.	lastTag := ''.	i := 0.	count := words size.	[i < count] whileTrue: 			[i := i + 1.			word := words at: i.			tag := tags at: i.	" reuse tag variable "			" First, handle all rules for i &gt; 1 "			i > 1 				ifTrue: 					[" rule 1: DT, {VBD | VBP} --> DT, NN "					lastTag = 'DT' & (tag = 'VBD' | (tag = 'VBP') | (tag = 'VB')) 						ifTrue: [tags at: i put: 'NN'].					tag size > 1 						ifTrue: 							[" rule 6: convert a noun to a verb if the preceeding work is 'would' "							(tag at: 1) = $N & ((tag at: 2) = $N) & (lastWord asLowercase = 'would') 								ifTrue: [tags at: i put: 'VB']]].			" Now, handle the remaining rules that are valid for i = 1: "			" rule 2: convert a noun to a number (CD) if '.' appears in the word"			(word findString: '.') > 0 				ifTrue: [(tag at: 1) = $N ifTrue: [tags at: i put: 'CD']].	" not working - tokenizer tosses '.' characters "			" rule 3: convert a noun to a past participle if words[i] ends with 'ed' "			(tag at: 1) = $N & (word endsWith: 'ed') ifTrue: [tags at: i put: 'VBN'].			" rule 4: convert any type to adverb if it ends in 'ly' "			(word endsWith: 'ly') ifTrue: [tags at: i put: 'RB'].			" rule 5: convert a common noun (NN or NNS) to a adjective if it ends with 'al' "			(tag at: 1) = $N & (word endsWith: 'al') ifTrue: [tags at: i put: 'JJ'].			" rule 7: if a word has been categorized as a common noun and it ends with 's;, "			"          then set its type to plural common noun (NNS) "			tag = 'NN' & (word endsWith: 's') ifTrue: [tags at: i put: 'NNS'].			" rule 8: convert a common noun to a present prticiple verb (i.e., a gerand) "			(tag at: 1) = $N & (word endsWith: 'ing') ifTrue: [tags at: i put: 'VBG'].			lastWord := word.			lastTag := tag].	^tags! !Object subclass: #NLPcategories	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KBSnlp'!!NLPcategories commentStamp: '<historical>' prior: 0!A NLPcategories is class to categorize text.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPcategories class	instanceVariableNames: ''!!NLPcategories class methodsFor: 'classify' stamp: 'MarkWatson 1/12/2015 12:02'!classify: text	"classify text in a string"	| tokens categories scores num hash numTokens results cutoff |	tokens :=  NLPtagger tokenize: text.	categories := (Smalltalk at: #NlpCategoryHash) keys.	num := categories size.	numTokens := tokens size.	scores := Array new: num.	1 to: num do: [ :i |		scores at: i put: 0.		hash := (Smalltalk at: #NlpCategoryHash) at: (categories at: i).		1 to: numTokens do: [ :j |			(hash includesKey: (tokens at: j))			  ifTrue: [scores at: i put: ((scores at: i) + (hash at: (tokens at: j)))] ]].	results := SortedCollection sortBlock: [:c1 :c2 | (c1 at:1) > (c2 at:1)]. 	1 to: num do: [ :i | |a| a := (Array new: 2). a at: 1 put: (scores at:i); at: 2 put: (categories at: i). results add: a ].	cutoff := ((results at: 1) at: 1) / 2.	results := results select: [ :x | (x at: 1) > cutoff ].	^results.	! !!NLPcategories class methodsFor: 'classify' stamp: 'MarkWatson 1/12/2015 10:22'!initializeCategoryHash	"requires NeoJSON"     Smalltalk at: #NlpCategoryHash                    put: (NeoJSONReader fromString: (FileStream fileNamed: './nlp_smalltalk/tags.json') contentsOfEntireFile)! !